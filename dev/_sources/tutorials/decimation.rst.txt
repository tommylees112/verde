.. note::
    :class: sphx-glr-download-link-note

    Click :ref:`here <sphx_glr_download_tutorials_decimation.py>` to download the full example code
.. rst-class:: sphx-glr-example-title

.. _sphx_glr_tutorials_decimation.py:


Data Decimation
===============

Often times, raw spatial data can be highly oversampled in a direction. In these cases,
we need to decimate the data before interpolation to avoid aliasing effects.



.. code-block:: python

    import matplotlib.pyplot as plt
    import cartopy.crs as ccrs
    import verde as vd







For example, our sample shipborne bathymetry data has a higher sampling frequency
along the tracks than between tracks:



.. code-block:: python


    # Load the data as a pandas.DataFrame
    data = vd.datasets.fetch_baja_bathymetry()

    # Plot it using matplotlib and Cartopy
    crs = ccrs.PlateCarree()
    plt.figure(figsize=(7, 7))
    ax = plt.axes(projection=ccrs.Mercator())
    ax.set_title("Locations of bathymetry measurements from Baja California")
    # Plot the bathymetry data locations as black dots
    plt.plot(data.longitude, data.latitude, ".k", markersize=1, transform=crs)
    vd.datasets.setup_baja_bathymetry_map(ax)
    plt.tight_layout()
    plt.show()




.. image:: /tutorials/images/sphx_glr_decimation_001.png
    :class: sphx-glr-single-img




Class :class:`verde.BlockReduce` can be used to apply a reduction/aggregation
operation (mean, median, standard deviation, etc) to the data in regular blocks. All
data inside each block will be replaced by their aggregated value.
:class:`~verde.BlockReduce` takes an aggregation function as input. It can be any
function that receives a numpy array as input and returns a single scalar value. The
:func:`numpy.mean` or :func:`numpy.median` functions are usually what we want.



.. code-block:: python

    import numpy as np







Blocked means and medians are good ways to decimate data for interpolation. Let's use
a blocked median on our data to decimate it to our desired grid interval of 5
arc-minutes. The reason for using a median over a mean is because bathymetry data can
vary abruptly and a mean would smooth the data too much. For data varies more
smoothly (like gravity and magnetic data), a mean would be a better option.



.. code-block:: python

    reducer = vd.BlockReduce(reduction=np.median, spacing=5 / 60)
    print(reducer)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    BlockReduce(adjust='spacing', center_coordinates=False,
          reduction=<function median at 0x2b9759387730>, region=None,
          spacing=0.08333333333333333)


Use the :meth:`~verde.BlockReduce.filter` method to apply the reduction:



.. code-block:: python

    coordinates, bathymetry = reducer.filter(
        coordinates=(data.longitude, data.latitude), data=data.bathymetry_m
    )

    plt.figure(figsize=(7, 7))
    ax = plt.axes(projection=ccrs.Mercator())
    ax.set_title("Locations of decimated data")
    # Plot the bathymetry data locations as black dots
    plt.plot(*coordinates, ".k", markersize=1, transform=crs)
    vd.datasets.setup_baja_bathymetry_map(ax)
    plt.tight_layout()
    plt.show()





.. image:: /tutorials/images/sphx_glr_decimation_002.png
    :class: sphx-glr-single-img




By default, the coordinates of the decimated data are obtained by applying the same
reduction operation to the coordinates of the original data. Alternatively, we can
tell :class:`~verde.BlockReduce` to return the coordinates of the center of each
block:



.. code-block:: python

    reducer_center = vd.BlockReduce(
        reduction=np.median, spacing=5 / 60, center_coordinates=True
    )
    coordinates_center, bathymetry = reducer_center.filter(
        coordinates=(data.longitude, data.latitude), data=data.bathymetry_m
    )

    plt.figure(figsize=(7, 7))
    ax = plt.axes(projection=ccrs.Mercator())
    ax.set_title("Locations of decimated data using block centers")
    # Plot the bathymetry data locations as black dots
    plt.plot(*coordinates_center, ".k", markersize=1, transform=crs)
    vd.datasets.setup_baja_bathymetry_map(ax)
    plt.tight_layout()
    plt.show()




.. image:: /tutorials/images/sphx_glr_decimation_003.png
    :class: sphx-glr-single-img




Now the data are ready for interpolation.


**Total running time of the script:** ( 0 minutes  1.075 seconds)


.. _sphx_glr_download_tutorials_decimation.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download

     :download:`Download Python source code: decimation.py <decimation.py>`



  .. container:: sphx-glr-download

     :download:`Download Jupyter notebook: decimation.ipynb <decimation.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.readthedocs.io>`_
